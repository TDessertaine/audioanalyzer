<!DOCTYPE html>

<!--
instructions.html

Copyright (C) 2016  Moritz Balter, Vlad Paul, Sascha Bilert
IHA @ Jade Hochschule applied licence see EOF

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

contact: sascha.bilert@student.jade-hs.de
-->

<html lang="en">

<head>

    <!-- define the meta data of the website -->
    <meta http-equiv="content-type" content="text/html" charset="UTF-8">

    <!-- set tab title of the website -->
    <title>Instructions</title>

    <!-- link to master.css and instructionssytle.css -->
    <link rel="stylesheet" href="css/master.css" type="text/css">
    <link rel="stylesheet" href="css/instructionsstyle.css" type="text/css">

    <!-- import image for tab icon -->
    <link rel="icon" type="image/png" href="image/icon.png">

    <!-- import audioprocessing.js to plot the window functions -->
    <script type="text/javascript" src="js/audioprocessing.js"></script>
    <script type="text/javascript" src="js/fft.js">
    </script>

    <!-- import plotly.js latest version to visulize data -->
    <script type="text/javascript" src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    <script type="text/javascript" src="js/plot.js"></script>

    <!-- import MathJax to user LateX for math formulars -->
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} });</script>

    <!-- import rainbow.js and different highlighting languages -->
    <script type="text/javascript" src="assets/rainbow/dist/rainbow.js"></script>
    <script type="text/javascript" src="assets/rainbow/language/javascript.js"></script>
    <script type="text/javascript" src="assets/rainbow/language/generic.js"></script>
    <link rel="stylesheet" href="assets/rainbow/themes/github.css" type="text/css" media="screen">

</head>

<!-- trigger plotWindow() function to plot the different windows -->

<body onload="plotWindow()">

    <!-- import a black github ribbon and link to the repository -->
    <a href="https://github.com/saschabilert/audioanalyzer" target="_blank">
        <img class="githubribbon" src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork us on GitHub"
            data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png">
    </a>

    <!-- define the header and the link to ref pages -->
    <header>
        <h1>Audioanalyzer</h1>
        <a href="index.html" class="link" target="_blank">Analyzer</a>
        <a href="instructions.html" class="link">
            <li class="currentpage">Instructions</li>
        </a>
        <a href="about.html" class="link" target="_blank">About</a>
    </header>

    <!-- define the items of the navigation bar -->
    <ul class="navigation">
        <li><a class="naviItems" href="#choosingAFile">Choosing a file</a></li>
        <li><a class="naviItems" href="#controlBar">Control Bar</a></li>
        <li><a class="naviItems" href="#waveform">Waveform</a></li>
        <li><a class="naviItems" href="#spectrogram">Spectrogram</a></li>
        <li><a class="naviItems" href="#parameters">Parameters</a></li>
        <li><a class="naviItems" href="#blockLength">Blocklength</a></li>
        <li><a class="naviItems" href="#windowType">Window-Types</a></li>
        <li><a class="naviItems" href="#overlap">Overlap</a></li>
        <li><a class="naviItems" href="#displayType">Display-Types</a></li>
        <li><a class="naviItems" href="#colormap">Colormaps</a></li>
        <li><a class="naviItems" href="#saveSpectrogram">Save Spectrogram</a></li>
    </ul>


    <p>This Website includes useful information about how to use the Audioanalyzer to analyse your audio file. In addition we tried to help the user by writing short tooltipps. If you need help to use the website you can navigate to the preferred help-section
        in the menu on the left side. The website is programmed by using the following technologies:</p>
    <ul>
        <li>JavaScript ES6 (JS ES6)</li>
        <li>Plotly (JS-Framework)</li>
        <li>Rainbow (JS-Framework)</li>
        <li>Hypertext Markup Language (HTML5)</li>
        <li>Cascading Style Sheet (CSS3)</li>
    </ul>

    <p style="margin-top: 16px;">The audioprocessing is based on a free FFT programmed in JavaScript (JS) by Nayuki. For more information visit <a href="https://www.nayuki.io/page/free-small-fft-in-multiple-languages" target="_blank">www.nayuki.io</a>. The main goal we adressed was
        to create an easy and useful tool to analyse audio files in terms of magnitude, phase and other values which are displayable and interpretable as a spectrogram. The user is able to apply different settings for various examinations. For describing
        the different windows, we used
        <b>plotly.js</b> for illustration and <b>rainbow.js</b> to highlight the code. We tried to describe all the parameters in an easy way in the instructions.</p>
    <h2><a id="choosingAFile">Choose a file:</a></h2>
    <figure>
        <img class="resizeImg" id="upload" src="image/upload.png">
        <figcaption>Figure 1: Upload the audio file which you want to analyse.</figcaption>
    </figure>
    <p>If you click on “Choose a file” you are able to import an audio file from you local computer. You can analyse different audio formats e.g. wav or mp3.
        <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats" target="_blank">(Click here for more audio formats)</a>. After you choose a file the waveform and the magintude-spectrum will be calculated and displayed below
        the buttons after the loading screen disappeared. The upload button now shows the name of your uploaded file. By clicking the button again, you can upload a new audio file. Your audio data won’t be saved at any point just analysed.</p>
    <h2><a id="controlBar">Control Bar:</a></h2>
    <figure>
        <img class="resizeImg" src="image/controlbar.png">
        <figcaption>Figure 2: Control bar to operate your sound in terms of play / stop for example.</figcaption>
    </figure>
    <p>You can play, pause and stop your uploaded track by using the different buttons in the control bar. Here you also find the button "Choose a file" which was described in the section before. You can also adjust the volume by using the volume slider
        next to the stop button. The numbers display the current playback time and the total length of the track in MM:SS:m separated by a slash. You can use the pause and play button to control the playback signal while you analyse it. It is also possible
        to loop a selected part of the audio file by ticking the box next to "Loop". How to select a part of your audio file is explained in the Waveform section. In case of analysis you can pick a matching grid size for the waveform including small,
        medium and large.</p>
    <h2><a id="waveform">Waveform:</a></h2>
    <figure>
        <img class="resizeImg" src="image/waveform.png">
        <figcaption>Figure 3: A view of the waveform of an uploaded audio file.</figcaption>
    </figure>
    <p>The waveform is compound by the linear amplitude (blue) and the RMS (lightblue). The RMS is calculated by RMS $= \sqrt{\dfrac{1}{N}\sum \limits_{i=0}^{N} n_{i}^{2}}$. On the x-axis you have the time scale and on the y-axis you have .... In the upper
        left corner you can see a legend showing your current mouse position when you move over the waveform. The legend includes the time, amplitude and the RMS. When you pushhit play after uploading an audio file, a red line shows the current time point
        in the waveform. If you click into the waveform and drag your mouse backward or forward you can select a single part of the waveform. When you release the mouse button your selection is shaded in transparent red. If you now push the play button
        you just play the selected part. It is also possible to use the Loop to repeat the selected audio part.</p>
    <h2><a id="spectrogram">Spectrogram:</a></h2>
    <figure>
        <img class="resizeImg" src="image/spectrum.png">
        <figcaption>Figure 4: A view of the spectrum of an uploaded audio file.</figcaption>
    </figure>
    <p>The spectrogram has different display types which are discussed in a section below. One thing they have in common, they are always three dimensional. On the x-axis you have the time and on the y-axis you have the frequency. If you move your cursor
        over the spectrogram the position data is displayed in the upper left corner. To identify the 3th dimension you have a legend for the colormap over the spectrogram on the right side. If you want to have more information you can zoom into the spectrogram
        by pressing the buttons down in the right corner of the spectrum window. You can zoom both the time and the frequency axis. As you have read in the last section, it is possible to select a short piece of your audio file. When you do that in the waveform, the spectrogram will automatically zoom in the selected part of the audio file. </p>
    <h2><a id="parameters">Parameters:</a></h2>
    <p style="margin-bottom: 20px;">You can customize the spectrogram individually by choosing the following listing parameters:</p>
    <table align="center" cellpadding="10">
        <caption>Table 1: Possible parameters to individualize the spectrogram. The gray fields show not free selectable parameters</caption>
        <tr>
            <th>Blocklength [samples]</th>
            <th>Window-Type</th>
            <th>Overlap [%]</th>
            <th>Display-Type</th>
            <th>Colormap</th>
        </tr>
        <tr>
            <td class="number">512</td>
            <td>hann</td>
            <td class="number">0</td>
            <td>spectrum</td>
            <td>viridis</td>
        </tr>
        <tr>
            <td class="number">1024</td>
            <td>rectangle</td>
            <td class="number">25</td>
            <td>phase</td>
            <td>gray</td>
        </tr>
        <tr>
            <td class="number">2048</td>
            <td>hann-poisson</td>
            <td class="number">50</td>
            <td>group delay</td>
            <td>jet</td>
        </tr>
        <tr>
            <td class="number">4096</td>
            <td>cosine</td>
            <td class="number">75</td>
            <td>instantaneous frequency deviation</td>
            <td>plasma</td>
        </tr>
        <tr>
            <td class="number">8192</td>
            <td>flat-top</td>
            <td class="number">90</td>
            <td class="none">-</td>
            <td class="disabled">twilight</td>
        </tr>
        <tr>
            <td class="none">-</td>
            <td>hamming</td>
            <td class="none">-</td>
            <td class="none">-</td>
            <td class="disabled">sunlight</td>
        </tr>
        <tr>
            <td class="none">-</td>
            <td>blackman</td>
            <td class="none">-</td>
            <td class="none">-</td>
            <td class="none">-</td>
        </tr>
    </table>
    <p>The default block length is 1024, the default window type is the hann window and the default overlap is 50%. The default type of the colormap is viridis, but you can choose between 4 colormaps. For the spectrum you can choose a minimal and a maximal
        value which zooms the spectrogram's value range. Depending on what you want to analyse you can choose between the four display types. The different display types (depending on the display type) are discussed in the section
        <b>Display-Types</b>.
    </p>
    <figure>
        <img class="resizeImg" src="image/parameters.png">
        <figcaption>Figure 5: Display the possible parameters to individualize the spectrogram.</figcaption>
    </figure>
    <p>In the Figure 5 you can see the different parameter-dropdown-menus and the lines for min and max range value. On the right side of the image you can see the spectrogram legend depending on the choosen display type.</p>
    <h2><a id="blockLength">Blocklength:</a></h2>
    <p>The block length is the number of samples used to divide the audio signal into equal blocks. In our case the block length is equal to the FFT-size. This means one bit in the spectrogram represents one audio sample and defines the frequency resolution
        of the window. For a 44100 Hz sample rate and a block size of 1024, the signal is being divided into 512 frequency bins. Changing the block length affects the temporal resolution and the coefficient quality of the spectrum. If you increase the
        block size, you will have an improved frequency resolution, because you have more bins in the same plot resolution. An increase of the block size slows the calculation time.</p>
    <h2><a id="windowType">Window-Types:</a></h2>
    <p>The following part is adressed to the different window types. We tried to explain the windows in various ways, mathematically, graphically and in the way we programmed them in JavaScript. In general a window can be explained as a weight for the audio signal
        in the time domain. If you take a look at a window itself in the time domain as well as in the frequency domain, you can categorize a window in three major classes and subclasses in the frequency domain (Quelle AMT):</p>
    <ul>
        <li>Spectral resolution</li>
        <ul>
            <li>-3 dB point</li>
            <li>Effective noise width</li>
            <li>Rippel factor</li>
        </ul>
        <li>Power of damping</li>
        <ul>
            <li>Damping of the first sidelobe</li>
            <li>Spectral roll-off</li>
            <li>$\Delta$f till damping &gt; 60dB</li>
        </ul>
        <li>Selectivity</li>
    </ul>
    <p style="margin-top: 0px;">The following subsections explain each window more detailed. You see the mathematical definition of the window, a illustration and the implementation. For illustration we used the Framework <b>Plotly.js</b>. All windows are calculated with the default
        length of 1024. The input for the windows were calculated with a linespace function in JS. To link the math part and the code we have $N$ = windowLen.length and $n$ = windowLen[i].</p>
    <pre class="code"><code data-language="javascript">/*
 * implementation of the linspace function make use of start value, end value
 * and the number of points between the start and end index
 */
 function linspace(startIdx, endIdx, n) {

      var linVector = new Array(n);

      for (var i = 0; i &lt; n; i++) {
            linVector[i] = startIdx + (i * (endIdx - startIdx) / n);
      }
      linVector[0] = startIdx;
      linVector[n - 1] = endIdx;
      return linVector;
 }</code></pre>
    <h3>1. Rect Window</h3>
    <p class="windowDef">The Rect Window is defined by: $w(n) = 1$</p>
    <div class="plot" id="divRect"></div>
    <pre class="code"><code data-language="javascript">/*
 * This code shows the implementation of an rect window in Javascript
 */

 var windowLen = linspace(0, 1024, 1024);
 var windowValueRect = calculateWindow(windowLen);

 function calculateWindow(windowLen) {
       var window = new Array(windowLen.length);
       window.fill(1);
       return window;
 }</code></pre>
    <h3>2. Hann Window</h3>
    <p class="windowDef">The Hann Window is defined by: $w(n) = \dfrac{1}{2}\left(1-\cos\left(\dfrac{2\pi n}{N-1}\right)\right)$</p>
    <div class="plot" id="divHann"></div>
    <pre class="code"><code data-language="javascript">/*
 * This code shows the implementation of an hann window in Javascript
 */

 var windowLen = linspace(0, 1024, 1024);
 var windowValueHann = calculateWindow(windowLen);

 function calculateWindow(windowLen) {
       var window = new Array(windowLen.length);
       for (i = 0; i &lt; windowLen.length; i++) {
           window[i] = 0.5 * (1 - Math.cos(2 * Math.PI *
                        windowLen[i] / (windowLen.length - 1)));
       }
       return window;
 }</code></pre>
    <h3>3. Hann-Poisson Window</h3>
    <p class="windowDef">The Hann-Poisson Window is defined by: $w(n) = \dfrac{1}{2}\left(1-\cos\left(\dfrac{2\pi n}{N-1}\right)\right)\text{e}^{{\dfrac{-\alpha\vert N-1-2n\vert}{N-1}}}$</p>
    <div class="plot" id="divHannPoisson"></div>
    <pre class="code"><code data-language="javascript">/*
 * This code shows the implementation of an hann-poisson window in Javascript
 */

 var windowLen = linspace(0, 1024, 1024);
 var windowValueHannPoisson = calculateWindow(windowLen);

 function calculateWindow(windowLen) {
       var window = new Array(windowLen.length);

       // alpha is a parameter that controls the slope of the exponential
       // (Wiki: https://en.wikipedia.org/wiki/Window_function)
       var alpha = 2;

       for (i = 0; i &lt; windowLen.length; i++) {
           window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * windowLen[i] / (windowLen.length - 1))) *
                        Math.exp((-alpha * Math.abs(windowLen.length - 1 - (2 * windowLen[i]))) /
                        (windowLen.length - 1));
       }
       return window;
 }</code></pre>
    <h3>4. Cosine Window</h3>
    <p class="windowDef">The Cosine Window is defined by: $w(n) = \cos\left(\dfrac{\pi n}{N-1}-\dfrac{\pi}{2}\right)$</p>
    <div class="plot" id="divCosine"></div>
    <pre class="code"><code data-language="javascript">/*
 * This shows the implementation of an cosine window in Javascript
 */

 var windowLen = linspace(0, 1024, 1024);
 var windowValueCosine = calculateWindow(windowLen);

 function calculateWindow(windowLen) {
       var window = new Array(windowLen.length);
       for (i = 0; i &lt; windowLen.length; i++) {
           window[i] = Math.cos(((Math.PI * windowLen[i]) /
                        (windowLen.length)) - (Math.PI / 2));
       }
       return window;
 }</code></pre>
    <h3>5. Flat-Top Window</h3>
    <p class="windowDef">The Flat-Top Window is defined by:</p>
    <p class="windowDef">$w(n) = \alpha_{0}-\alpha_{1}\cos\left(\dfrac{2\pi n}{N-1}\right)+ \alpha_{2}\cos\left(\dfrac{4\pi n}{N-1}\right)- \alpha_{3}\cos\left(\dfrac{6\pi n}{N-1}\right)+ \alpha_{4}\cos\left(\dfrac{8\pi n}{N-1}\right)$</p>
    <p class="windowDef">$\alpha_{0} = 1$; $\alpha_{1} = 1.93$; $\alpha_{2} = 1.29$; $\alpha_{3} = 0.388$; $\alpha_{4} = 0.028$</p>
    <div class="plot" id="divFlatTop"></div>
    <pre class="code"><code data-language="javascript">/*
 * This code shows the implementation of an flat-top window in Javascript
 */

 var windowLen = linspace(0, 1024, 1024);
 var windowValueFlatTop = calculateWindow(windowLen);

 function calculateWindow(windowLen) {
       var window = new Array(windowLen.length);

       // alpha is a parameter that controls the slope of the window
       // (Wiki: https://en.wikipedia.org/wiki/Window_function)
       var alpha = [1, 1.93, 1.29, 0.388, 0.028];

       for (i = 0; i &lt; windowLen.length; i++) {
           window[i] = alpha[0]
                        - alpha[1] * Math.cos(2 * Math.PI * windowLen[i] / (windowLen.length - 1))
                        + alpha[2] * Math.cos(4 * Math.PI * windowLen[i] / (windowLen.length - 1))
                        - alpha[3] * Math.cos(6 * Math.PI * windowLen[i] / (windowLen.length - 1))
                        + alpha[4] * Math.cos(8 * Math.PI * windowLen[i] / (windowLen.length - 1));
       }
       return window;
 }</code></pre>
    <h3>6. Hamming Window</h3>
    <p class="windowDef">The Hamming Window is defined by: $w(n) = \alpha - \beta \cos\left(\dfrac{2\pi n}{N-1}\right)$</p>
    <p class="windowDef">$\alpha = 0.54$; $\beta = 1 - \alpha = 0.46$</p>
    <div class="plot" id="divHamming"></div>
    <pre class="code"><code data-language="javascript">/*
 * This shows the implementation of an hamming window in Javascript
 */

 var windowLen = linspace(0, 1024, 1024);
 var windowValueHamming = calculateWindow(windowLen);

 function calculateWindow(windowLen) {
      var window = new Array(windowLen.length);

      // alpha and beta are parameters that control the slope of the window
      // (Wiki: https://en.wikipedia.org/wiki/Window_function)
      var alpha = 0.54;
      var beta = 1 - alpha;

      for (i = 0; i &lt; windowLen.length; i++) {
          window[i] = alpha - beta * Math.cos((2 * Math.PI * windowLen[i]) / (windowLen.length - 1));
      }
      return window;
 }</code></pre>
    <h3>6. Blackman Window</h3>
    <p class="windowDef">The Blackman Window is defined by: $w(n) = \alpha_{0} - \alpha_{1} \cos\left(\dfrac{2\pi n}{N-1}\right) + \alpha_{2} \cos\left(\dfrac{4\pi n}{N-1}\right)$</p>
    <p class="windowDef">$\alpha_{0} = \dfrac{1 - \alpha}{2}$; $\alpha_{1} = \dfrac{1}{2}$; $\alpha_{2} = \dfrac{\alpha}{2}$; $\alpha = 0.16$</p>
    <div class="plot" id="divBlackman"></div>
    <pre class="code"><code data-language="javascript">/*
 * This shows the implementation of an blackman window in Javascript
 */

 var windowLen = linspace(0, 1024, 1024);
 var windowValueBlackman = calculateWindow(windowLen);

 function calculateWindow(windowLen) {
      var window = new Array(windowLen.length);

      // alpha is a parameter that controls the slope of the window
      // (Wiki: https://en.wikipedia.org/wiki/Window_function)
      var alpha = 0.16;
      var alpha0 = (1 - alpha) / 2;
      var alpha1 = 1 / 2;
      var alpha2 = alpha / 2;

      for (i = 0; i &lt; windowLen.length; i++) {
          window[i] = alpha0
                        - alpha1 * Math.cos((2 * Math.PI * windowLen[i]) / (windowLen.length - 1))
                        + alpha2 * Math.cos((4 * Math.PI * windowLen[i]) / (windowLen.length - 1));
      }
      return window;
 }</code></pre>
    <h2><a id="overlap">Overlap:</a></h2>
    <p>The images below tries to illustrate two different overlaps. When you select an overlap of 90% the calculation may take a little bit longer. The more percentage overlap you choose, the more sample blocks will be transformed from the time domain into
        the frequency domain.</p>
    <figure>
        <img class="resizeImg" src="image/overlap0.png">
        <figcaption>Figure 1: Illustration of a 0% Overlap.</figcaption>
    </figure>
    <figure>
        <img class="resizeImg" src="image/overlap75.png">
        <figcaption>Figure 1: Illustration of a 75% Overlap.</figcaption>
    </figure>
    <h2><a id="displayType">Display-Types:</a></h2>
    <p>HERE COMES SOMETHING ABOUT THE display type</p>
    <h3>1. FFT</h3>
    <pre class="code"><code data-language="javascript">// calculate the fft depending on the given sampleblock
function calculateFFT(sampleBlock) {

      var imag = new Array(sampleBlock.length).fill(0);
      var real = sampleBlock;

      // call the fft from Nayuki (see fft.js for more information)
      transform(real, imag);

      return [real, imag];
}</code></pre>
    <h3>2. Spectrum</h3>
    <pre class="code"><code data-language="javascript">// calculate the absolute value of the spectrogram data (see formula in instructions.html)
function calculateAbs(real, imag) {

      var absValue = new Array(Audiodata.blockLen / 2 + 1);

      for (i = 0; i &lt; absValue.length; i++) {
            absValue[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]);
      }
      return absValue;
}</code></pre>
    <h3>3. Phase</h3>
    <pre class="code"><code data-language="javascript">// calculate the phase of the spectrogram data (see formula in instructions.html)
function calculatePhase(real, imag) {

      var phaseValue = new Array(real.length / 2 + 1);

      for (i = 0; i &lt; phaseValue.length; i++) {
            phaseValue[i] = Math.atan2(imag[i], real[i]);
      }
      return phaseValue;
 }</code></pre>
    <h3>4. Group Delay</h3>
    <pre class="code"><code data-language="javascript">/*
 * calculate the group delay using calcluatePhase() and linspace() (see formula
 * in instructions.html)
 */
 function calculateGroupDelay(real, imag) {

       var phase = calculatePhase(real, imag);

       var freqVector = linspace(0, Audiodata.sampleRate / 2, Audiodata.blockLen / 2);

       var dOmega = (freqVector[2] - freqVector[1]) * 2 * Math.PI;

       var dPhase = diff(phase);

       var groupDelay = new Array(dPhase.length);

       for (var k = 0; k &lt; dPhase.length; k++) {
             if (dPhase[k] &gt; Math.PI) {
                   dPhase[k] = dPhase[k] - 2 * Math.PI;
             } else if (dPhase[k] &lt; (-1 * Math.PI)) {
                   dPhase[k] = dPhase[k] + 2 * Math.PI;
             }
             groupDelay[k] = -1 * dPhase[k] / dOmega;
       }
       return groupDelay;
 }</code></pre>
    <h3>5. Instantaneous Frequency Deviation</h3>
    <pre class="code"><code data-language="javascript">/*
 * calculate the instantaneous frequency deviation for more informations see
 * the instructions.html website
 */
 function calculateInstantFreqDev(sampleBlock, windowType) {

       var InstHopsize = Audiodata.sampleRate / Audiodata.wrapFreq;

       var newSampleBlockLen = Math.round(sampleBlock.length - InstHopsize);

       var windowLen = linspace(0, newSampleBlockLen, newSampleBlockLen);

       var window = calculateWindow(windowLen, windowType);

       var firstSampleBlock = sampleBlock.slice(0, newSampleBlockLen);

       var secondSampleBlock = sampleBlock.slice(sampleBlock.length
                              - newSampleBlockLen, sampleBlock.length);

       for (var i = 0; i &lt; newSampleBlockLen; i++) {
             firstSampleBlock[i] = firstSampleBlock[i] * window[i];
            secondSampleBlock[i] = secondSampleBlock[i] * window[i];
       }

       var [firstReal, firstImag] = calculateFFT(firstSampleBlock);
       var [secondReal, secondImag] = calculateFFT(secondSampleBlock);

       var firstPhase = calculatePhase(firstReal, firstImag);

       var secondPhase = calculatePhase(secondReal, secondImag);

       var instantFreq = new Array(newSampleBlockLen / 2 + 1).fill(0);
       var instantFreqDev = new Array(instantFreq.length).fill(0);

       var freq = linspace(0, Audiodata.sampleRate / 2, instantFreq.length);

       for (var k = 0; k &lt; instantFreq.length; k++) {
             var dPhase = secondPhase[k] - firstPhase[k];

             instantFreq[k] = dPhase * Audiodata.wrapFreq / (2 * Math.PI);

             instantFreq[k] = instantFreq[k] + Math.round((freq[k] - instantFreq[k]) /
                              Audiodata.wrapFreq) * Audiodata.wrapFreq;

             instantFreqDev[k] = instantFreq[k] - freq[k];
       }
       return instantFreqDev;
 }</code></pre>
    <h2><a id="colormap">Colormaps:</a></h2>
    <p>HERE COMES SOMETHING ABOUT THE colormap</p>
    <h2><a id="saveSpectrogram">Save Spectrogram:</a></h2>
    <p>HERE COMES SOMETHING ABOUT THE SAVEBUTTON</p>
</body>

</html>
